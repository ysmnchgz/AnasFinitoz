<!DOCTYPE html>

<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YEYY LIBART√â</title>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@600&family=Fredoka+One&display=swap" rel="stylesheet">

  <style>
    * { margin: 0; padding: 0; }
    
    body {
      overflow: hidden;
      font-family: 'Dancing Script', cursive;
      background: radial-gradient(circle, #000428 0%, #004e92 50%, #000000 100%);
      cursor: crosshair;
      height: 100vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .message {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #ffd700;
      font-size: clamp(2rem, 5vw, 4rem);
      text-align: center;
      opacity: 0;
      text-shadow: 0 0 15px #ffd700, 0 0 30px #ffff33;
      animation: entrance 1.5s ease-out 1.5s forwards;
      z-index: 10;
      font-family: 'Fredoka One', cursive;
      letter-spacing: 2px;
      pointer-events: none;
    }

    .subtitle {
      font-size: 0.6em;
      margin-top: 10px;
      font-family: 'Dancing Script', cursive;
      color: #87ceeb;
    }

    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.8);
      font-size: 1.1rem;
      opacity: 0;
      animation: fadeIn 1s ease-in 3.5s forwards;
      pointer-events: none;
    }

    @keyframes entrance {
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes fadeIn {
      to { opacity: 1; }
    }
  </style>

</head>

<body>
  <canvas id="canvas"></canvas>
  <div class="message">
    üéäü•≥ Youpiii t'as enfin fini ü•≥üéä
    <div class="subtitle"> ‚ö°Ô∏èüåü Bravo, t'es le + meilleur üåü‚ö°Ô∏è</div>
  </div>
  <div class="hint">‚ú® Touches moi si tu veux √©clater partoutüòè ‚ú®</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width = canvas.width = innerWidth;
    let height = canvas.height = innerHeight;
    
    addEventListener('resize', () => {
      width = canvas.width = innerWidth;
      height = canvas.height = innerHeight;
    });

    const particlePool = [];
    const activeParticles = [];
    const maxParticles = 800;
    
    const colors = ['#ffd700', '#ffff00', '#ff6b6b', '#4ecdc4', '#45b7d1', '#ff9ff3', '#54a0ff', '#feca57'];
    const sparkleColors = ['#ffffff', '#ffd700', '#87ceeb'];

    class Particle {
      constructor() {
        this.reset(0, 0, 0, 0, '#fff', 0, 'circle');
      }

      reset(x, y, vx, vy, color, life, type) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.life = this.maxLife = life;
        this.size = Math.random() * 2.5 + 1.5;
        this.type = type;
        this.rotation = Math.random() * 6.28;
        this.rotSpeed = (Math.random() - 0.5) * 0.15;
        return this;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.985;
        this.vy *= 0.985;
        this.vy += 0.015;
        this.life--;
        this.rotation += this.rotSpeed;
        return this.life > 0;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        if (alpha < 0.01) return;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.x, this.y);
        
        if (this.type === 'star') {
          ctx.rotate(this.rotation);
          ctx.fillStyle = this.color;
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.beginPath();
          
          const s = this.size;
          ctx.moveTo(0, -s);
          ctx.lineTo(s * 0.3, -s * 0.3);
          ctx.lineTo(s, 0);
          ctx.lineTo(s * 0.3, s * 0.3);
          ctx.lineTo(0, s);
          ctx.lineTo(-s * 0.3, s * 0.3);
          ctx.lineTo(-s, 0);
          ctx.lineTo(-s * 0.3, -s * 0.3);
          ctx.closePath();
          ctx.fill();
        } else {

          ctx.fillStyle = this.color;
          ctx.shadowBlur = 8;
          ctx.shadowColor = this.color;
          ctx.beginPath();
          ctx.arc(0, 0, this.size, 0, 6.28);
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    for (let i = 0; i < maxParticles; i++) {
      particlePool.push(new Particle());
    }

    function getParticle(x, y, vx, vy, color, life, type = 'circle') {
      if (particlePool.length > 0 && activeParticles.length < maxParticles) {
        const p = particlePool.pop();
        activeParticles.push(p.reset(x, y, vx, vy, color, life, type));
        return p;
      }
      return null;
    }

    function returnParticle(particle) {
      const index = activeParticles.indexOf(particle);
      if (index > -1) {
        activeParticles.splice(index, 1);
        particlePool.push(particle);
      }
    }

    function createExplosion(x, y, intense = false) {
      const count = intense ? 120 : 80;
      const colorArray = intense ? colors : colors.slice(0, 4);
      
      for (let i = 0; i < count; i++) {
        const angle = (6.28 * i) / count + Math.random() * 0.4;
        const speed = Math.random() * (intense ? 10 : 7) + 3;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        const color = colorArray[Math.floor(Math.random() * colorArray.length)];
        const life = 90 + Math.random() * 40;
        const type = Math.random() < 0.4 ? 'star' : 'circle';
        
        getParticle(x, y, vx, vy, color, life, type);
      }
    }

    function createSparkles(x, y) {
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * 6.28;
        const speed = Math.random() * 3 + 1;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        const color = sparkleColors[Math.floor(Math.random() * sparkleColors.length)];
        
        getParticle(x, y, vx, vy, color, 40, 'star');
      }
    }

    let frameCount = 0;
    let lastSparkle = 0;
    let autoExplosionTimer = 0;

    function animate() {
      frameCount++;
      
      if (frameCount % 2 === 0) {
        ctx.fillStyle = 'rgba(0, 4, 40, 0.12)';
        ctx.fillRect(0, 0, width, height);
      }

      for (let i = activeParticles.length - 1; i >= 0; i--) {
        const p = activeParticles[i];
        if (!p.update()) {
          returnParticle(p);
        } else {
          p.draw();
        }
      }

      if (frameCount - lastSparkle > 30 && Math.random() < 0.08) {
        createSparkles(Math.random() * width, Math.random() * height);
        lastSparkle = frameCount;
      }

      autoExplosionTimer++;
      if (autoExplosionTimer > 240) { 
        createExplosion(Math.random() * width, Math.random() * height, true);
        autoExplosionTimer = 0;
      }

      requestAnimationFrame(animate);
    }

    let lastClick = 0;
    let mouseMoveThrottle = 0;

    canvas.addEventListener('click', (e) => {
      const now = Date.now();
      if (now - lastClick < 100) return; 
      lastClick = now;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      createExplosion(x, y, true);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (frameCount - mouseMoveThrottle < 5) return; 
      mouseMoveThrottle = frameCount;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      if (Math.random() < 0.3) {
        createSparkles(x, y);
      }
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      createExplosion(x, y, true);
    }, { passive: false });

    setTimeout(() => {
      createExplosion(width / 2, height / 2, true);
    }, 800);

    animate();
  </script>

</body>
</html>
